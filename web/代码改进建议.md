# 代码维护性和模块化改进建议

## 三、组件架构问题

### 3.1 Options API 和 Composition API 混用
**问题位置：** `src/components/common/AvatarName.vue`, `src/App.vue`

**问题描述：**
- 同一组件中混用两种 API 风格
- 代码风格不一致，难以维护

**改进建议：**
统一使用 Composition API（Vue 3 推荐）：
```vue
<!-- AvatarName.vue 改进示例 -->
<script setup>
import { ref, onMounted } from 'vue'
import { getCookie } from '@/utils/cookie'
import { globalProfileCacher } from '@/utils/global_img_cache'
import { acquireLock, releaseLock } from '@/utils/lock'
import { openPage } from '@/utils/other'
import { getProfileUrl } from '@/utils/profile'

const props = defineProps({
  initData: {
    type: Object,
    default: () => ({ id: null, name: null })
  },
  size: { type: String, default: '30' },
  color: { type: String, default: '#000' },
  clickable: { type: Boolean, default: true },
  ifShowName: { type: Boolean, default: true },
  nameSize: { type: String, default: '16' }
})

const profileUrl = ref(null)

const toAuthorPage = () => {
  if (!props.clickable) return
  
  const routeName = getCookie("userId") == props.initData.id 
    ? 'SelfPage' 
    : 'AuthorPage'
  
  openPage("router", {
    name: routeName,
    params: { id: props.initData.id }
  })
}

const getProfile = async () => {
  const cacheKey = globalProperties.$apiUrl + '/image/user?user_id=' + props.initData.id
  const cached = globalProfileCacher.getImage(cacheKey)
  
  if (cached) {
    profileUrl.value = cached
    return
  }
  
  profileUrl.value = await getProfileUrl(props.initData.id)
}

onMounted(async () => {
  const lockKey = 'profile-' + props.initData.id
  await acquireLock(lockKey)
  try {
    await getProfile()
  } finally {
    releaseLock(lockKey)
  }
})
</script>
```

### 3.2 Props 命名不一致
**问题描述：**
- 有些组件用 `initData`，有些用 `data`
- 缺少统一的命名规范

**改进建议：**
- 统一使用 `initData` 作为初始数据 prop
- 组件内部使用 `data` 作为响应式数据
- 创建组件开发规范文档

### 3.3 组件职责不清
**问题位置：** `src/App.vue` (450+ 行)

**问题描述：**
- App.vue 承担了太多职责（导航、搜索、对话框管理等）
- 应该拆分为更小的组件

**改进建议：**
```
src/components/layout/
  ├── AppNavBar.vue        # 导航栏
  ├── AppSearchBar.vue     # 搜索栏
  ├── AppBottomNav.vue     # 底部导航
  └── AppDialog.vue        # 对话框容器
```

---


### 4.2 错误处理不统一
**问题描述：**
- 虽然定义了 `dealAxiosError`，但各 API 文件使用方式不一致
- 缺少统一的错误处理中间件

**改进建议：**
```javascript
// src/axios/interceptors.js
export function setupResponseInterceptor(axiosInstance) {
  axiosInstance.interceptors.response.use(
    response => response,
    async error => {
      const handledError = await dealAxiosError(error)
      // 统一处理错误
      return Promise.reject(handledError)
    }
  )
}
```
---

## 五、状态管理问题

### 5.1 Store 过于简单
**问题位置：** `src/store/index.js`

**问题描述：**
- 只有基本的用户状态
- 缺少模块化组织

**改进建议：**
```javascript
// src/store/modules/user.js
export default {
  namespaced: true,
  state: () => ({
    user: null,
    cookie: null,
  }),
  getters: {
    isLoggedIn: (state) => !!state.cookie,
  },
  mutations: {
    SET_USER(state, user) {
      state.user = user
    },
    // ...
  },
  actions: {
    // ...
  }
}

// src/store/index.js
import { createStore } from 'vuex'
import user from './modules/user'
import editor from './modules/editor'

export default createStore({
  modules: {
    user,
    editor,
  }
})
```

---

## 六、路由管理问题

### 6.1 路由守卫逻辑复杂
**问题位置：** `src/router/index.js`

**问题描述：**
- beforeEach 中逻辑过多
- 调试路由处理逻辑复杂

**改进建议：**
```javascript
// src/router/guards/auth.js
export function setupAuthGuard(router) {
  router.beforeEach((to, from, next) => {
    if (to.matched.some(record => record.meta.requiresAuth)) {
      // 认证逻辑
      next()
    } else {
      next()
    }
  })
}

// src/router/guards/debug.js
export function setupDebugGuard(router) {
  router.beforeEach((to, from, next) => {
    if (to.name.endsWith("Debug") && (!from.name || !from.name.endsWith("Debug"))) {
      startDebug()
      window.alert("本页面处于调试模式")
    }
    next()
  })
}

// src/router/index.js
import { setupAuthGuard } from './guards/auth'
import { setupDebugGuard } from './guards/debug'

const router = createRouter({ ... })
setupAuthGuard(router)
setupDebugGuard(router)
```
---

## 七、类型安全

### 7.1 缺少类型检查
**问题描述：**
- 项目使用 JavaScript，缺少类型检查
- Props 定义不够严格

**改进建议：**
- 考虑迁移到 TypeScript
- 或者使用 JSDoc 注释增强类型提示：
```javascript
/**
 * @typedef {Object} ArticleData
 * @property {string} id
 * @property {string} title
 * @property {string} content
 */

/**
 * @param {ArticleData} article
 * @returns {Promise<ArticleData>}
 */
export async function processArticle(article) {
  // ...
}
```

---

## 八、代码质量

### 8.1 缺少代码规范
**改进建议：**
- 使用 ESLint + Prettier 统一代码风格
- 添加 pre-commit hooks（husky + lint-staged）
- 配置 `.editorconfig`

### 8.2 注释和文档
**改进建议：**
- 为复杂函数添加 JSDoc 注释
- 创建组件使用文档
- 添加 API 使用示例

### 8.3 测试覆盖
**改进建议：**
- 添加单元测试（Jest + Vue Test Utils）
- 添加 E2E 测试（Cypress 或 Playwright）
- 关键业务逻辑必须有测试覆盖

---

## 九、性能优化

### 9.1 组件懒加载
**改进建议：**
- 路由组件已使用懒加载，但可以优化
- 大型组件使用 `defineAsyncComponent`

---

## 十、目录结构优化

### 10.1 建议的新目录结构
```
src/
  ├── api/              # API 调用（重命名自 axios）
  │   ├── modules/
  │   └── request.js
  ├── assets/           # 静态资源
  ├── components/       # 组件
  │   ├── common/       # 通用组件
  │   ├── layout/       # 布局组件
  │   └── [feature]/    # 功能组件
  ├── config/           # 配置文件
  ├── composables/      # 组合式函数（新增）
  ├── constants/        # 常量定义（新增）
  ├── pages/            # 页面
  ├── router/           # 路由
  ├── store/            # 状态管理
  │   └── modules/      # Store 模块
  ├── styles/           # 样式文件（重命名自 style）
  ├── types/            # 类型定义（如果使用 TS）
  └── utils/            # 工具函数
      └── [category]/   # 按类别组织
```

---

## 十一、具体改进优先级



### 中优先级（近期改进）
1. ⚠️ 组件重构：统一使用 Composition API
3. ⚠️ Store 模块化：拆分状态管理模块
4. ⚠️ 代码规范：添加 ESLint/Prettier 配置

### 低优先级（长期规划）
1. 📋 TypeScript 迁移
2. 📋 测试覆盖
3. 📋 性能优化
4. 📋 文档完善

---

## 十二、实施建议

1. **渐进式重构**：不要一次性重构所有代码，按模块逐步改进
2. **保持向后兼容**：重构时确保现有功能不受影响
3. **代码审查**：建立代码审查机制，确保新代码符合规范
4. **文档先行**：在重构前先完善相关文档
5. **测试保障**：重构后及时添加测试，防止回归

---

## 总结

主要问题集中在：
- 配置管理混乱
- 工具函数组织不当
- 组件架构不统一
- 缺少类型安全
- 代码规范不完善

建议按照优先级逐步改进，重点关注配置管理和代码组织，这将显著提升代码的可维护性。

